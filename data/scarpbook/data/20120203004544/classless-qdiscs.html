<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:cf="http://docbook.sourceforge.net/xmlns/chunkfast/1.0">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>6.&nbsp;Classless Queuing Disciplines (qdiscs)</title><meta name="generator" content="DocBook XSL Stylesheets V1.69.0"><link rel="start" href="http://linux-ip.net/articles/Traffic-Control-HOWTO/index.html" title="Traffic Control HOWTO"><link rel="up" href="http://linux-ip.net/articles/Traffic-Control-HOWTO/index.html" title="Traffic Control HOWTO"><link rel="prev" href="http://linux-ip.net/articles/Traffic-Control-HOWTO/software.html" title="5.&nbsp;Software and Tools"><link rel="next" href="http://linux-ip.net/articles/Traffic-Control-HOWTO/classful-qdiscs.html" title="7.&nbsp;Classful Queuing Disciplines (qdiscs)"><meta xmlns="http://www.w3.org/TR/xhtml1/transitional" name="generator" content="Experimental LDP.XSL $Revision: 1.2 $">
  <!-- Generated by LDP XSLT customization layer
      based on Norman Walsh's DocBook XSL stylesheets.
      More information at http://www.linuxdoc.org/ -->
  
<link rel="stylesheet" type="text/css" href="classless-qdiscs.css" media="all">
</head>
<body><div class="navheader"><table summary="Navigation header" width="100%"><tbody><tr><th colspan="3" align="center">6.&nbsp;Classless Queuing Disciplines (<code class="constant">qdisc</code>s)</th></tr><tr><td width="20%" align="left"><a indepth="true" accesskey="p" href="software.html">Prev</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;<a indepth="true" accesskey="n" href="classful-qdiscs.html">Next</a></td></tr></tbody></table><hr></div><div class="section" xml:lang="en" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both;"><a id="classless-qdiscs"></a>6.&nbsp;Classless Queuing Disciplines (<a indepth="true" href="components.html#c-qdisc" title="4.1.&nbsp;qdisc"><code class="constant">qdisc</code></a>s)</h2></div></div></div><p>
    Each of these queuing disciplines can be used as the primary qdisc on an
    interface, or can be used inside a leaf class of a <a indepth="true" href="classful-qdiscs.html" title="7.&nbsp;Classful Queuing Disciplines (qdiscs)">classful qdiscs</a>.
    These are the fundamental schedulers used under Linux.  Note that the
    default scheduler is the <a indepth="true" href="classless-qdiscs.html#qs-pfifo_fast" title="6.2.&nbsp;pfifo_fast, the default Linux qdisc"><code class="constant">pfifo_fast</code></a>.
  </p><p>
  </p><div class="section" xml:lang="en" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="qs-fifo"></a>6.1.&nbsp;FIFO, First-In First-Out (<code class="constant">pfifo</code> and <code class="constant">bfifo</code>)</h3></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Note]" src="note.png"></td><th align="left">Note</th></tr><tr><td valign="top" align="left">
      This is not the default qdisc on Linux interfaces.  Be certain to see
      <a indepth="true" href="classless-qdiscs.html#qs-pfifo_fast" title="6.2.&nbsp;pfifo_fast, the default Linux qdisc">Section&nbsp;6.2, “<code class="constant">pfifo_fast</code>, the default Linux qdisc”</a> for the full details on the default
      (<code class="constant">pfifo_fast</code>) qdisc.
    </td></tr></tbody></table></div><p>
      The FIFO algorithm forms the basis for the default qdisc on all Linux
      network interfaces (<a indepth="true" href="classless-qdiscs.html#qs-pfifo_fast" title="6.2.&nbsp;pfifo_fast, the default Linux qdisc"><code class="constant">pfifo_fast</code></a>).  It performs no shaping or
      rearranging of packets.  It simply transmits packets as soon as it can
      after receiving and queuing them.  This is also the qdisc used inside
      all newly created classes until another qdisc or a class replaces the
      FIFO.
    </p><div class="mediaobject"><a id="img-qs-fifo"></a><img src="fifo-qdisc.png"></div><p>
      A real FIFO qdisc must, however, have a size limit (a buffer size) to
      prevent it from overflowing in case it is unable to dequeue packets as
      quickly as it receives them.  Linux implements two basic FIFO
      <a indepth="true" href="components.html#c-qdisc" title="4.1.&nbsp;qdisc"><code class="constant">qdisc</code></a>s, one based on bytes, and one on packets.  Regardless of
      the type of FIFO used, the size of the queue is defined by the parameter
      <em class="parameter"><code>limit</code></em>.  For a <code class="constant">pfifo</code> the unit is understood
      to be packets and for a <code class="constant">bfifo</code> the unit is understood to be bytes.
    </p><div class="example"><a id="ex-qs-fifo-limit"></a><p class="title"><b>Example&nbsp;6.&nbsp;Specifying a <em class="parameter"><code>limit</code></em> for a packet
        or byte FIFO</b></p><table xmlns="http://www.w3.org/TR/xhtml1/transitional" bgcolor="#E0E0E0" border="0" width="90%"><tbody><tr><td><pre class="programlisting"><code xmlns="http://www.w3.org/1999/xhtml" class="prompt">[root@leander]# </code><strong xmlns="http://www.w3.org/1999/xhtml" class="userinput"><code>cat bfifo.tcc</code></strong>
<code xmlns="http://www.w3.org/1999/xhtml" class="computeroutput">/*
 * make a FIFO on eth0 with 10kbyte queue size
 *
 */

dev eth0 {
    egress {
        fifo (limit 10kB );
    }
}</code>
<code xmlns="http://www.w3.org/1999/xhtml" class="prompt">[root@leander]# </code><strong xmlns="http://www.w3.org/1999/xhtml" class="userinput"><code>tcc &lt; bfifo.tcc</code></strong>
<code xmlns="http://www.w3.org/1999/xhtml" class="computeroutput"># ================================ Device eth0 ================================

tc qdisc add dev eth0 handle 1:0 root dsmark indices 1 default_index 0
tc qdisc add dev eth0 handle 2:0 parent 1:0 bfifo limit 10240</code>
<code xmlns="http://www.w3.org/1999/xhtml" class="prompt">[root@leander]# </code><strong xmlns="http://www.w3.org/1999/xhtml" class="userinput"><code>cat pfifo.tcc</code></strong>
<code xmlns="http://www.w3.org/1999/xhtml" class="computeroutput">/*
 * make a FIFO on eth0 with 30 packet queue size
 *
 */

dev eth0 {
    egress {
        fifo (limit 30p );
    }
}</code>
<code xmlns="http://www.w3.org/1999/xhtml" class="prompt">[root@leander]# </code><strong xmlns="http://www.w3.org/1999/xhtml" class="userinput"><code>tcc &lt; pfifo.tcc</code></strong>
<code xmlns="http://www.w3.org/1999/xhtml" class="computeroutput"># ================================ Device eth0 ================================

tc qdisc add dev eth0 handle 1:0 root dsmark indices 1 default_index 0
tc qdisc add dev eth0 handle 2:0 parent 1:0 pfifo limit 30</code>
      </pre></td></tr></tbody></table></div></div><div class="section" xml:lang="en" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="qs-pfifo_fast"></a>6.2.&nbsp;<code class="constant">pfifo_fast</code>, the default Linux qdisc</h3></div></div></div><p>
      The <code class="constant">pfifo_fast</code> qdisc is the default qdisc for all interfaces under
      Linux.  Based on a conventional <a indepth="true" href="classless-qdiscs.html#qs-fifo" title="6.1.&nbsp;FIFO, First-In First-Out (pfifo and bfifo)">FIFO</a> qdisc, this qdisc also
      provides some prioritization.  It provides three different bands
      (individual FIFOs) for separating traffic.  The highest priority traffic
      (interactive flows) are placed into band 0 and are always serviced
      first.  Similarly, band 1 is always emptied of pending packets before
      band 2 is dequeued.
    </p><div class="mediaobject"><a id="img-qs-pfifo_fast"></a><img src="pfifo_fast-qdisc.png"></div><p>
      There is nothing configurable to the end user about the <code class="constant">pfifo_fast</code>
      qdisc.  For exact details on the <code class="constant">priomap</code> and use of
      the ToS bits, see the <a xmlns="http://www.w3.org/TR/xhtml1/transitional" class="nonlocal" href="http://lartc.org/howto/lartc.qdisc.classless.html" target="_top">pfifo-fast
         section of the LARTC HOWTO</a>.
    </p></div><div class="section" xml:lang="en" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="qs-sfq"></a>6.3.&nbsp;SFQ, Stochastic Fair Queuing</h3></div></div></div><p>
      The SFQ qdisc attempts to fairly distribute opportunity to
      transmit data to the network among an arbitrary number of
      <a indepth="true" href="overview.html#o-flows" title="2.6.&nbsp;Flows">flows</a>.  It accomplishes this by using a hash function to
      separate the traffic into separate (internally maintained) FIFOs
      which are dequeued in a round-robin fashion.  Because there is the
      possibility for unfairness to manifest in the choice of hash function,
      this function is altered periodically.  Perturbation (the parameter
      <em class="parameter"><code>perturb</code></em>) sets this periodicity.
    </p><div class="mediaobject"><a id="img-qs-sfq"></a><img src="sfq-qdisc.png"></div><div class="example"><a id="ex-qs-sfq"></a><p class="title"><b>Example&nbsp;7.&nbsp;Creating an SFQ</b></p><table xmlns="http://www.w3.org/TR/xhtml1/transitional" bgcolor="#E0E0E0" border="0" width="90%"><tbody><tr><td><pre class="programlisting"><code xmlns="http://www.w3.org/1999/xhtml" class="prompt">[root@leander]# </code><strong xmlns="http://www.w3.org/1999/xhtml" class="userinput"><code>cat sfq.tcc</code></strong>
<code xmlns="http://www.w3.org/1999/xhtml" class="computeroutput">/*
 * make an SFQ on eth0 with a 10 second perturbation
 *
 */

dev eth0 {
    egress {
        sfq( perturb 10s );
    }
}</code>
<code xmlns="http://www.w3.org/1999/xhtml" class="prompt">[root@leander]# </code><strong xmlns="http://www.w3.org/1999/xhtml" class="userinput"><code>tcc &lt; sfq.tcc</code></strong>
<code xmlns="http://www.w3.org/1999/xhtml" class="computeroutput"># ================================ Device eth0 ================================

tc qdisc add dev eth0 handle 1:0 root dsmark indices 1 default_index 0
tc qdisc add dev eth0 handle 2:0 parent 1:0 sfq perturb 10</code>
      </pre></td></tr></tbody></table></div><p>
      Unfortunately, some clever software (<span class="foreignphrase"><em class="foreignphrase">e.g.</em></span> Kazaa and eMule among others)
      obliterate the benefit of this attempt at fair queuing by opening as
      many TCP sessions (<a indepth="true" href="overview.html#o-flows" title="2.6.&nbsp;Flows">flows</a>) as can be sustained.  In many
      networks, with well-behaved users, SFQ can adequately distribute
      the network resources to the contending flows, but other measures may be
      called for when obnoxious applications have invaded the network.
    </p><p>
      See also
      <a indepth="true" href="classless-qdiscs.html#qs-esfq" title="6.4.&nbsp;ESFQ, Extended Stochastic Fair Queuing">Section&nbsp;6.4, “ESFQ, Extended Stochastic Fair Queuing”</a> for an SFQ qdisc with more exposed
      parameters for the user to manipulate.
    </p></div><div class="section" xml:lang="en" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="qs-esfq"></a>6.4.&nbsp;ESFQ, Extended Stochastic Fair Queuing</h3></div></div></div><p>
      Conceptually, this qdisc is no different than SFQ although it
      allows the user to control more parameters than its simpler cousin.
      This qdisc was conceived to overcome the shortcoming of SFQ
      identified above.  By allowing the user to control which hashing
      algorithm is used for distributing access to network bandwidth, it
      is possible for the user to reach a fairer real distribution of
      bandwidth.
    </p><div class="example"><a id="ex-qs-esfq-usage"></a><p class="title"><b>Example&nbsp;8.&nbsp;ESFQ usage</b></p><table xmlns="http://www.w3.org/TR/xhtml1/transitional" bgcolor="#E0E0E0" border="0" width="90%"><tbody><tr><td><pre class="programlisting">Usage: ... esfq [ perturb SECS ] [ quantum BYTES ] [ depth FLOWS ]
        [ divisor HASHBITS ] [ limit PKTS ] [ hash HASHTYPE]

Where:
HASHTYPE := { classic | src | dst }
      </pre></td></tr></tbody></table></div><p>
      FIXME; need practical experience and/or attestation here.
    </p></div><div class="section" xml:lang="en" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="qs-gred"></a>6.5.&nbsp;GRED, Generic Random Early Drop</h3></div></div></div><p>
      FIXME; I have never used this.  Need practical experience or
      attestation.
    </p><p>
      Theory declares that a RED algorithm is useful on a backbone or core
      network, but not as useful near the end-user.  See the section on
      <a indepth="true" href="overview.html#o-flows" title="2.6.&nbsp;Flows">flows</a> to see a general discussion of the thirstiness of TCP.
    </p></div><div class="section" xml:lang="en" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="qs-tbf"></a>6.6.&nbsp;TBF, Token Bucket Filter</h3></div></div></div><p>
      This qdisc is built on <a indepth="true" href="overview.html#o-tokens" title="2.7.&nbsp;Tokens and buckets">tokens</a> and <a indepth="true" href="overview.html#o-buckets">buckets</a>.  It
      simply shapes traffic transmitted on an interface.  To limit the speed
      at which packets will be dequeued from a particular interface, the
      TBF qdisc is the perfect solution.  It simply slows down
      transmitted traffic to the specified rate.
    </p><p>
      Packets are only transmitted if there are sufficient tokens available.
      Otherwise, packets are deferred.  Delaying packets in this fashion will
      introduce an artificial latency into the packet's round trip time.
    </p><div class="mediaobject"><a id="img-qs-tbf"></a><img src="tbf-qdisc.png"></div><div class="example"><a id="ex-qs-tbf"></a><p class="title"><b>Example&nbsp;9.&nbsp;Creating a 256kbit/s TBF</b></p><table xmlns="http://www.w3.org/TR/xhtml1/transitional" bgcolor="#E0E0E0" border="0" width="90%"><tbody><tr><td><pre class="programlisting"><code xmlns="http://www.w3.org/1999/xhtml" class="prompt">[root@leander]# </code><strong xmlns="http://www.w3.org/1999/xhtml" class="userinput"><code>cat tbf.tcc</code></strong>
<code xmlns="http://www.w3.org/1999/xhtml" class="computeroutput">/*
 * make a 256kbit/s TBF on eth0
 *
 */

dev eth0 {
    egress {
        tbf( rate 256 kbps, burst 20 kB, limit 20 kB, mtu 1514 B );
    }
}</code>
<code xmlns="http://www.w3.org/1999/xhtml" class="prompt">[root@leander]# </code><strong xmlns="http://www.w3.org/1999/xhtml" class="userinput"><code>tcc &lt; tbf.tcc</code></strong>
<code xmlns="http://www.w3.org/1999/xhtml" class="computeroutput"># ================================ Device eth0 ================================

tc qdisc add dev eth0 handle 1:0 root dsmark indices 1 default_index 0
tc qdisc add dev eth0 handle 2:0 parent 1:0 tbf burst 20480 limit 20480 mtu 1514 rate 32000bps</code>
      </pre></td></tr></tbody></table></div><p>
    </p></div></div><div class="navfooter"><hr><table summary="Navigation footer" width="100%"><tbody><tr><td width="40%" align="left"><a indepth="true" accesskey="p" href="software.html">Prev</a>&nbsp;</td><td width="20%" align="center">&nbsp;</td><td width="40%" align="right">&nbsp;<a indepth="true" accesskey="n" href="classful-qdiscs.html">Next</a></td></tr><tr><td valign="top" width="40%" align="left">5.&nbsp;Software and Tools&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="http://linux-ip.net/articles/Traffic-Control-HOWTO/index.html">Home</a></td><td valign="top" width="40%" align="right">&nbsp;7.&nbsp;Classful Queuing Disciplines (<code class="constant">qdisc</code>s)</td></tr></tbody></table></div>


</body></html>
