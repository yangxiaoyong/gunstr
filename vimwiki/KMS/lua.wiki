程序块 chunk
Lua 执行的每段代码，例如一个源代码文件或交互模式中输入的一行代码，都称为一个“程序块”
一个程序块也就是一连串的语句或命令
x^2 == x 的2次方
x^0.5 == x 的开平方根

词法规范
1. 不能以数字开头
2. 应该尽量避免以一个下画线开头并跟着一个或多个大写字母（例如_VERSION）的标识符
   Lua将这类标识符保留用作特殊用途，通常保留标识符"_"作为“哑变量”（dummy variable）
   使用
3. 注释： --, `--[[ --]]`,

全局变量
全局变量不需要生命，只需要将一个值赋予一个全局变量就可以创建了，在lua中，访问一个未
初始化的变量不会引发错误，访问结果是一个特殊的值nil.

要打印任何表达式的值，可以用等号开头

=== 类型与值 ===
lua中有8种基础类型：
  - nil
  - boolean
  - number
  - string
  - userdata (自定义数据)
  - function
  - thread
  - table
type 函数总是返回一个字符串
- nil: 主要功能是用于区别其它任何值
- boolean: false 和 true, 在lua中除nil和false外全为真
- number: 用于表示实数（双精度浮点数），lua没有整数类型
  4 0.4 4.57e-3 0.3e12 5e+20
- string: lua中的字符串通常表示“一个字符序列”。lua完全采用8位编码，lua字符中的字符可以
  具有任何数值编码，包括数值0.也就是说，可以将任意二进制数据存储到一个字符串中。
  luar中的字符串是不可改变的值（immutable values）
  `..` 是字符串连接操作符
  `#`: 长度操作符
- table: 表类型实现了“关联数组”。“关联数组”是一种具有特殊索引方式的数组。不仅可以通过
  整数来索引它，还可以使用字符串或其他类型的值（除nil）来索引它
  a.x = 10 等同于 a["x"] = 10
  - 点的写法可能更明确的暗示了读者，将table作为一条记录来使用，每条记录都有一组固定的
  预定义的key。
  - 而字符串的写法可能暗示了该table会以任何字符串作为key，而现在处于某些原因，需要
  访问某个特定的key
  - 数组通常以1作为索引的起始值
  - 长度操作符"#" 用于返回一个数组或线性表的最后一个索引值（或为其大小）
  数组为有序的集合
  以下是集中长度操作符在Lua中的习惯写法：
  {{{
    print(a[#a])   -- 打印列表a的最后一个值
    a[#a] = nil    -- 删除最后一个值
    -- 如果v 不存在，那就不会增加，也不会抛异常，按里说v没有赋值，就会是nil，
    -- 那么就相当于复制一个nil的值，等价于删除该索引的值，不是吗？
    a[#a+1] = v    -- 将v添加到列表末尾
  }}}
- function: 函数作为“第一类值”来看待的，这表示函数可以存储在变量中，
  可以通过参数传递给其他函数，还可以作为其他函数的返回值
- userdata, thread: 自定义类型用于表示一种由应用程序或C语言库所创建的新
  类型。
  线程类型

=== 表达式 ===
lua 支持的常规算数表达式：
- 二元的 `+, -, *, /, ^(指数), %(去模)`
- 一元的`-(负号)`

{{{
a % b = a - floor(a/b) * b
对于整数来说：上面的算式都是有意义的，计算结果的符号永远与第二个参数相同。
而对于实数来说，则有其它用户，如，x%1的结果就是x的小数部分，而x-x%1的结果就是
其整数部分。类似的， x-x%0.01则是x精确到小数点后二位的结果

x = math.pi
print(x - x%0.01) --> 3.14
}}}

关系操作符号
lua提供以下关系操作符号： `< > <= >= == ~=`
所有的这些操作符号运算结果都是true或false
对于table, userdata 和函数， lua 是作引用比较的

逻辑操作符
逻辑操作符有: `and, or not`
`and` 和 `or` 都使用 “短路求值（short-cut evaluation）”，也就是说它们只会在需要时才去评
估第二个操作数。短路求值可以确保（`(type(v)=="table" and v.tag=="h1"`）这样的表达式
当v不是一个table时，lua不会对v.tag进行求值评估
不会导致运行错误
有一种常用的lua习惯写法 "x=x or v"，它等价于：
{{{
if not x then x = v end
}}}
还有一种习惯写法是"`(a and b) or c`" 前提是b不为假
{{{
max = ( x > y) and x or y
}}}

字符串连接
要在lua中连接两个字符串，可以使用操作符号“..”，如果其任意一个操作数是数字的话，lua会将
这个数字转换成一个字符串：
{{{
print("hello" .. "World") --> Hello world
print("0 .. 1") --> 01
}}}

优先级

| ^               |
|-----------------|
| not # - (一元)  |
|-----------------|
| * / %           |
|-----------------|
| + -             |
|-----------------|
| ..              |
|-----------------|
| < > <= >= ~= == |
|-----------------|
| and             |
|-----------------|
| or              |
|-----------------|
在二云操作符中，除指数"`^`"和连接操作符号"`..`"是“右结合”的，所有其它操作
符都是“左结合（left associative）”的
{{{
x^^y^z <--> x^(y^z)
}}}
若不确定某些操作的优先级，就应显式的用括号来指定期望的运算次序

table构造式
构造式是用于创建和初始化table的表达式, 最简单的构造式就是一个空构造式`{}`，用
于创建一个空table
{{{
days = {"Sunday", "Monday",  "Thuesday", "Wednesday", "Thursday",
        "Friday", "Saturday"}
}}}
会将`days[1]`初始化"Sunday", `days[2]`初始化为"Monday", 以此类推
构造式的第一个元素的索引是1，而非0
lua 还提供了一种特殊的语法用于初始化记录风格的table:
{{{
a = {x=10, y=20}
等价于
a = {}, a.x=10, a.y=20
}}}

无论是用那种方式来创建table，都可以在table创建之后添加或删除其中的某些字段
{{{
w = {x=0, y=0, label="console"}
x = {math.sin(10), math.sin(1), math.sin(2)}
w[1] = "another field"  -- 添加key 1 到 table w
x.f = w                 -- 添加key f 到 table w
print(w["x"])
}}}

=== 语句 ===
局部变量: 通过local语句来创建局部变量
与全局变量不同的是，局部变量的作用域仅限于声明它们的那个块
一个块（block）是一个控制结构的执行体，或者是一个函数的执行体再或者是一个程序块（chunk）

在需要时才声明变量，可以使这个变量在初始化时刻就拥有一个有意义的初值。此外，缩短变量的
作用域有助于提供代码的可读性

控制结构

用于条件执行的`if`，用于迭代的`while， repeat, for`。所有的控制结构都有一个显式的终止
符：`if`, `for` 和 `while` 以`end`作为结尾，`repeat`以`until`作为结尾

=== 函数 ===
一个函数若只有一个参数，并且此参数是一个字面字符串或table构造式，那么圆括号可有可无
lua 为面向对象式的调用也提供了一种特殊的语法--冒号操作符。
表达式`o.foo(o, x)`的另一种写法是`o:foo(x)`，冒号操作符使调用o.foo时将o隐含地作为函
数的第一个参数

=== 深入函数 ===
First-Class Value: 第一类值, 表示lua中函数和其它传统类型的值（例如数字和字符串）具有相同
的权利。函数可以存储到变量中（无论是全局变量还是局部变量）或table中，可以做为实参传递给
其它函数，还可以作为其它函数的返回值
Lexical Scoping: 词法域, 指一个函数可以嵌套在另一个函数中，内部的函数可以访问外部函数中的
变量。

闭合函数

正确的尾调用（proper tail call）
支持尾调用消除（tail-calling eliminiation）

=== 迭代器与泛型for ===

=== 协同程序(coroutine) ===
