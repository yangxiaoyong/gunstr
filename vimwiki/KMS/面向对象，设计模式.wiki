类的属性，在声明和赋值前加一个代表可见性的关键字（keyword）
这个关键字是 public, protected 或 private ，它决定了属性的作用域

require 和 include 的不同之处在于它们如何处理错误
使用require调用文件发生错误时，将会停止整个程序；
调用include时遇到相同的错误，则会生成警告并停止执行包含文件，跳出调用代码后继续执行

require_once：函数只能在文件没有被包含过的情况下才能包含它

组合优于继承 （Favor composition over inheritance）


使用 `->` 来访问对象的方法或属性

参数和类型
整型，字符，布尔型都是基本类型（primitive type）
没个类都定义了一种数据类型，因此，`ShopProduct`对象属于基本类型，但同时也属于`ShoproDuct`
这一类型

引用一个类而不是对象的方法，可以使用`::`
{{{
parent::__construct()
}}}


访问方法： 不推荐直接访问属性来获得和修改属性值，而是提供方法来去的需要的值
类常量一旦设置就不能改变其值

抽象类： 不能直接被实例化，抽象类中只定义（或部分实现）子类需要的方法。
         子类可以继承它并且通过实现其中的抽象方法，使抽象类具体化
接口： 抽象类提供了具体实现的标准，而接口则是纯粹的模版。接口只能定义个能，而不包含实现
       的内容。接口可用关键字interface来横名。接口可以包含属性和方法生命，但是方法体为空
       实现接口的类接受了它继承的类及实现的接口的类型。

异常： Exception类的构造方法接受二个可选的参数：小西字符串和错误代码


=== 对象工具 ===
包(package): PHP没有直接支持“包”机制，但我们应该将代码组织成累是于“包”的结构
包含路径(include path): 为你的类库代码设置访问路径
类函数和对象函数：测试对象，类，属性和方法的函数
反射API（Reflection API）: 一组强大的内置类，可以在代码运行时访问类信息。

==== PHP和包 ====
包是一组相关类的集合，这些类以某种方式组合在一起。包可以把系统的一部分和其他部分分隔开来
PEAR使用文件系统来定义包，然后每个类都根据包路径来命名，没个路径名以下划线来分隔

例如： PEAR有一个XML包，XML包中有一个RPC子包，RPC包中有一个Serve.php文件。在Server.php
中定义的类不是直接叫做Server，而是被命名为 XML_RPC_Server

反射API(Reflection API): 由一系列可以分析属性，方法和类的内置类组成。它在某些方面
                         和已经学过的对象函数累是，比如get_class_vars()，但是更加
                         灵活，而且可以提供更多信息
                         访问控制，接口和抽象类
不可缺少的类测试工具

==== 对象与设计 ====
- 设计基础： 设计是什么？面向对象设计和过程式编程有什么不同?
- 类的内容： 如何决定一个类中应该包含什么？
- 封装（encapsulation）: 在类的接口后面隐藏实现和数据。
- 多态（polymorphism）: 使用同一个父类，允许在运行时透明的替换特定的子类
- UML: 使用图表来描述面向对象结构

===== 代码设计的定义 =====
确定系统的需求，作用域和目标。
系统需要做什么？谁需要使用它？系统输出的内容是什么？系统可以满足一定的需求吗？
从底层上看，设计是定义系统组成并组织各组件间关系的过程。
从另一个角度来考虑，类和对象的定义与配置。

面向对象和过程式编程的一个核心区别是如何分配职责。
过程式表现为一系列命令和方法的连续调用。控制代码根据不同的条件执行不同的职责。这种
自顶向下的控制方式导致了重复和相互依赖的代码遍布于整个项目。
面向对象编程则将职责从客户端代码中移动到专门的对象中，尽量减少相互依赖

内聚（cohesion）：是一个模块内部各成分之间相关联程度的度量。理想情况下，你应该使各组件
职责清晰，分工明确。

耦合: 当系统各部分代码紧密绑在一起时，就会产生紧密耦合，这时一个组件的改变会迫使其他
部件随之改变。

正交（orthogonality）:将职责相关的组件紧紧组合在一起，而与外部系统环境隔开，保持独立
多态：
封装： 对客户端代码隐藏数据和功能
要实现封


松散耦合高内聚

定义一个良好的接口后加入实现代码是很容易的

==== 四个方向标 ====
- 代码重复
- 类知道的太多
- 万能的类
- 条件语句
-
聚合和组合
与关联很相似，聚合（aggregation）和组合（composition)都描述了一个类长期持有其他类的一个或
多个实例的情况。通过聚合和组合，被引用的对象实例成为引用对象的一部分。

在聚合的情况下，包含对象是容器的一个核心部分，但是它们也可以同时被其他对象所包含。
组合则是一个更强的关系，在组合中，包含对象只能被它的容器所引用。当容器被删除时，它也应该
被删除

=== 什么是设计模式？为何要使用它们 ===
- 模式基础： 什么是设计模式？
- 模式结构： 每个设计模式的关键元素？
- 模式收益： 为何模式值得你花时间学习？

模式便是特定环境下同类问题的一种解决方案。

=== 模式原则 ===
设计模式不只是简单的描述了问题的解决方案，而且很重视解决方案的可重用性和灵活性。
- 组合: 如何通过聚合对象来获得比只使用继承更好的灵活性
- 解耦： 如何降低系统中元素间的依赖性
- 接口的作用： 模式和多态
- 模式分类：

